<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>groupcache源码分析1:consistenthash.go</title>
    <url>/2020/03/09/groupcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/</url>
    <content><![CDATA[<p>consistenthash.go文件主要是提供一个Map数据结构，它基于一致性哈希算法，来达到根据缓存的key名，去寻找对应服务器结点的作用。</p>
<a id="more"></a>

<h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>参考文章：<a href="https://www.cnblogs.com/cloudgeek/p/9427036.html">https://www.cnblogs.com/cloudgeek/p/9427036.html</a></p>
<p>假设我们有三台机器，有一个key需要缓存到其中一台上，我们可以通过hash(key)%N的方式来取余，这样结果必定是其中的一台机器。<br>但是上面的方式存在一个缺点，就是如果增加或者减少结点，那么其中的缓存会被大量的转移。</p>
<p>一致性哈希的方式，是将存在的机器串在一起，首尾相连，看起来每台机器就是圆上的一个点。然后我们将hash(key)的值跟其最近一个点关联，存储在该台机器上，这样当该结点消失，我们只需要重新分配与其关联的缓存即可。如果添加结点，也只需要将已经存在某结点的部分缓存进行重新分配。<br>但是这种方式，同样存在一个缺点，如果结点较少，很容易分配不均，某台过多或者过少。</p>
<p>于是，我们引入虚拟结点的概念，将hash(机器+num)与机器做关联，通过缓存-&gt;虚拟结点-&gt;结点的形式进行绑定，增加了数据分配的平衡性。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><ol>
<li>Hash定义了一个函数类型，接受[]byte返回uint32，他表示我们选择哈希运算方法类型。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Hash <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">uint32</span></span></span><br></pre></td></tr></table></figure></li>
<li>Map是一个数据结构，用来保存hash后的结点。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	hash     Hash <span class="comment">//哈希算法类型</span></span><br><span class="line">	replicas <span class="keyword">int</span> <span class="comment">//每个机器的虚拟结点数</span></span><br><span class="line">	keys     []<span class="keyword">int</span> <span class="comment">//哈希环上的一个点，其值为结点哈希算法后的返回值，升序排列</span></span><br><span class="line">	hashMap  <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> <span class="comment">//映射关系，key为keys中保存的值，val是对应机器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>初始化方法，返回一个Map数据结构。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(replicas <span class="keyword">int</span>, fn Hash)</span> *<span class="title">Map</span></span> &#123;</span><br><span class="line">	m := &amp;Map&#123;</span><br><span class="line">		replicas: replicas,</span><br><span class="line">		hash:     fn,</span><br><span class="line">		hashMap:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> m.hash == <span class="literal">nil</span> &#123;</span><br><span class="line">		m.hash = crc32.ChecksumIEEE</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判断Map是否为空。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.keys) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将机器结点添加到Map中。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Add</span><span class="params">(keys ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.replicas; i++ &#123; <span class="comment">//生成虚拟结点</span></span><br><span class="line">			hash := <span class="keyword">int</span>(m.hash([]<span class="keyword">byte</span>(strconv.Itoa(i) + key)))</span><br><span class="line">			m.keys = <span class="built_in">append</span>(m.keys, hash)</span><br><span class="line">			m.hashMap[hash] = key</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Ints(m.keys) <span class="comment">//排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获取结点机器的方法。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m.IsEmpty() &#123; <span class="comment">//非空判断</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hash := <span class="keyword">int</span>(m.hash([]<span class="keyword">byte</span>(key))) <span class="comment">//生成key的哈希，这里key代表的是缓存数据的key</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历[0,n),查找到符合func返回true的最小i值，若都不符合条件返回n</span></span><br><span class="line">	idx := sort.Search(<span class="built_in">len</span>(m.keys), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> m.keys[i] &gt;= hash &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里想一下不难理解，如果是一条直线的话，我们一直取比hash值大的那个结点</span></span><br><span class="line">    <span class="comment">//如果这个结点不存在，则取结点0</span></span><br><span class="line">	<span class="keyword">if</span> idx == <span class="built_in">len</span>(m.keys) &#123;</span><br><span class="line">		idx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返会结点对应机器</span></span><br><span class="line">	<span class="keyword">return</span> m.hashMap[m.keys[idx]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>groupcache</category>
      </categories>
      <tags>
        <tag>groupcache</tag>
      </tags>
  </entry>
  <entry>
    <title>groupcache源码分析2:groupcachepb</title>
    <url>/2020/03/10/groupcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/</url>
    <content><![CDATA[<p>groupcachepb打开后我们可以看到.proto文件和.pb.go文件，这玩意儿我们很熟悉，protobuf协议嘛，我们只需要关注.proto即可，.pb.go是基于他生成，关于protobuf的具体内容不详述，大家知道他是一个用来进行通信的协议即可。</p>
<a id="more"></a>

<ol>
<li>协议版本和包名。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> groupcachepb;</span><br></pre></td></tr></table></figure></li>
<li>请求消息结构，两个字符串，分别为group和key，必须字段。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message GetRequest &#123;</span><br><span class="line">  required <span class="keyword">string</span> group = <span class="number">1</span>;</span><br><span class="line">  required <span class="keyword">string</span> key = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>回复消息结构，[]byte和double类型，可选字段。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message GetResponse &#123;</span><br><span class="line">  optional bytes value = <span class="number">1</span>;</span><br><span class="line">  optional double minute_qps = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>rpc服务定义，但是我貌似没有在代码中看到使用rpc的地方。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">service GroupCache &#123;</span><br><span class="line">  rpc Get(GetRequest) returns (GetResponse) &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>groupcache</category>
      </categories>
      <tags>
        <tag>groupcache</tag>
      </tags>
  </entry>
  <entry>
    <title>groupcache源码分析3:lru.go</title>
    <url>/2020/03/11/groupcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903/</url>
    <content><![CDATA[<p>LRU算法全称Least Recently Used ，最近最少使用，当数据所占内存达到一定阈值，我们要移除掉最近最少使用的数据。</p>
<a id="more"></a>

<ol>
<li>定义了一个缓存结构体，MaxEntries表示缓存的数量上限，值为0不限制。OnEvicted是一个func类型，当缓存被淘汰时被调用。ll是一个双向链表指针，链表两头分别为最新和最旧的数据。cache是一个map，k是缓存名，v是链表中元素指针。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">	MaxEntries <span class="keyword">int</span></span><br><span class="line">	OnEvicted <span class="function"><span class="keyword">func</span><span class="params">(key Key, value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">	ll    *list.List</span><br><span class="line">	cache <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*list.Element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Key是定义的类型，可包含任何对象。entry结构体，缓存的单位。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Key <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	key   Key</span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>初始化方法，创建一个lru缓存。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxEntries <span class="keyword">int</span>)</span> *<span class="title">Cache</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">		MaxEntries: maxEntries,</span><br><span class="line">		ll:         list.New(),</span><br><span class="line">		cache:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*list.Element),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>添加方法，先惰性加载cache和ll属性，虽然new的时候会创建他俩，但是若执行clear方法会把这两个属性又置为了nil，所以这里要判断。然后判断新加的key是否已经存在，若存在将其移到ll的最前方，并返回value。否则，创建entry，将其加入ll的最前方，cache保存其在ll中的元素指针。开启了缓存限制，并且ll大小已超，调用RemoveOldest方法。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Add</span><span class="params">(key Key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*list.Element)</span><br><span class="line">		c.ll = list.New()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ee, ok := c.cache[key]; ok &#123;</span><br><span class="line">		c.ll.MoveToFront(ee)</span><br><span class="line">		ee.Value.(*entry).value = value</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">	c.cache[key] = ele</span><br><span class="line">	<span class="keyword">if</span> c.MaxEntries != <span class="number">0</span> &amp;&amp; c.ll.Len() &gt; c.MaxEntries &#123;</span><br><span class="line">		c.RemoveOldest()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获取缓存，cache不存在，直接返回空。若key存在，获取其值，将其移到ll最前方。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key Key)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ele, hit := c.cache[key]; hit &#123;</span><br><span class="line">		c.ll.MoveToFront(ele)</span><br><span class="line">		<span class="keyword">return</span> ele.Value.(*entry).value, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>removeElement，移除一个单位，分别从ll和cache中移除，若定义了OnEvicted，调用该方法。Remove包装了removeElement，为实际对外使用的方法名。RemoveOldest，获取ll最后一个元素，将其删除。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Remove</span><span class="params">(key Key)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ele, hit := c.cache[key]; hit &#123;</span><br><span class="line">		c.removeElement(ele)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">RemoveOldest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ele := c.ll.Back()</span><br><span class="line">	<span class="keyword">if</span> ele != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.removeElement(ele)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">removeElement</span><span class="params">(e *list.Element)</span></span> &#123;</span><br><span class="line">	c.ll.Remove(e)</span><br><span class="line">	kv := e.Value.(*entry)</span><br><span class="line">	<span class="built_in">delete</span>(c.cache, kv.key)</span><br><span class="line">	<span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.OnEvicted(kv.key, kv.value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获取缓存的总数。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.ll.Len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>清理所有缓存，OnEvicted不为nil，遍历元素执行回调，然后将ll和cache置为nil，因为这个缘故所以在Add方法最开始有一个惰性加载。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, e := <span class="keyword">range</span> c.cache &#123;</span><br><span class="line">			kv := e.Value.(*entry)</span><br><span class="line">			c.OnEvicted(kv.key, kv.value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.ll = <span class="literal">nil</span></span><br><span class="line">	c.cache = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>groupcache</category>
      </categories>
      <tags>
        <tag>groupcache</tag>
      </tags>
  </entry>
  <entry>
    <title>groupcache源码分析4:singleflight.go</title>
    <url>/2020/03/14/groupcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904/</url>
    <content><![CDATA[<p>singleflight.go文件代码不多，主要是提供了一个竞争执行方法，利用sync.WaitGroup来让重复的请求，进行等待，只实际执行一次，并将执行结果返回给所有等待的请求。算是一个并发的处理机制。</p>
<a id="more"></a>

<p>关于sync.WaitGroup的简单使用就是在创建一个任务的时候wg.Add(1), 任务完成的时候使用wg.Done()来将任务减一。使用wg.Wait()来阻塞等待所有任务完成。</p>
<ol>
<li><p>call结构体表示实际的一个请求，包括返回值，错误，和wg。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">	wg  sync.WaitGroup</span><br><span class="line">	val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Group结构体表示一类工作，可以当成命名空间，对于同一个Group下的相同key请求我们只执行一次方法。m是map，对应保存请求key和他的call指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Do方法是本文件的核心，我们具体看下。<br>先判断key是否咋g.m中存在，如果存在，那么说明同一个key被多次请求了，我们得到call指针，调用Wait方法，进行阻塞等待，等到call指针执行完后，取得val和err返回即可。注意这里加锁的操作，防止取数据时，m被修改了。假如g.m[key]不存在，那么说明当前是key的第一个请求，new(call)返回指针并且c.wg.Add(1)，实际上在整个过程中，也只会Add这一次，将其放入map。等待fn()完成后，执行Done()方法，解除Wait的阻塞，将值返回给其他多次相同请求。最后从map中移除，收尾工作完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">		c.wg.Wait()</span><br><span class="line">		<span class="keyword">return</span> c.val, c.err</span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">new</span>(call)</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	g.m[key] = c</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	c.val, c.err = fn()</span><br><span class="line">	c.wg.Done()</span><br><span class="line"></span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="built_in">delete</span>(g.m, key)</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>groupcache</category>
      </categories>
      <tags>
        <tag>groupcache</tag>
      </tags>
  </entry>
  <entry>
    <title>groupcache源码分析6:sink.go</title>
    <url>/2020/03/21/groupcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%906/</url>
    <content><![CDATA[<p>sink.go文件实际上也是提供数据结构，在ByteView之上做了一层封装。</p>
<a id="more"></a>

<ol>
<li><p>Sink接口，提供三个set方法和一个view方法，view方法返回ByteView。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Sink <span class="keyword">interface</span> &#123;</span><br><span class="line">	SetString(s <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">	SetBytes(v []<span class="keyword">byte</span>) error</span><br><span class="line"></span><br><span class="line">	SetProto(m proto.Message) error</span><br><span class="line"></span><br><span class="line">	view() (ByteView, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[]byte类型拷贝。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cloneBytes</span><span class="params">(b []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">	<span class="built_in">copy</span>(c, b)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setSinkView方法，将一个ByteView内容设置到Sink中。注意这里viewSetter的使用，通过它去断言s是否包含setView方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setSinkView</span><span class="params">(s Sink, v ByteView)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> viewSetter <span class="keyword">interface</span> &#123;</span><br><span class="line">		setView(v ByteView) error</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> vs, ok := s.(viewSetter); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> vs.setView(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s.SetBytes(v.b)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.SetString(v.s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件中定义了不少实现Sink接口的结构体，但是代码中实际只用到了allocBytesSink。我们这里只单独分析一下它。创建方法和allocBytesSink结构体定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AllocatingByteSliceSink</span><span class="params">(dst *[]<span class="keyword">byte</span>)</span> <span class="title">Sink</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;allocBytesSink&#123;dst: dst&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> allocBytesSink <span class="keyword">struct</span> &#123;</span><br><span class="line">	dst *[]<span class="keyword">byte</span> <span class="comment">//这里有一个疑问，此属性有什么用呢？看代码它还是一个新分配地址，但是view方法并不需要它啊。</span></span><br><span class="line">	v   ByteView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>view方法没啥可说的。值得注意得是另一个setView方法，我们可以使用第2步中的setSinkView方法来赋值。还有一个有意思的点，如果v存储了[]byte，那么cloneBytes方法创建出了一个新的切片赋值，否则通过string转[]byte生成一个新的切片赋值(一个新知识点：[]byte的变量赋值指向同一个地址，string和[]byte的转换是数据复制)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *allocBytesSink)</span> <span class="title">view</span><span class="params">()</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *allocBytesSink)</span> <span class="title">setView</span><span class="params">(v ByteView)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		*s.dst = cloneBytes(v.b)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*s.dst = []<span class="keyword">byte</span>(v.s)</span><br><span class="line">	&#125;</span><br><span class="line">	s.v = v</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用[]byte设置s和v</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *allocBytesSink)</span> <span class="title">setBytesOwned</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.dst == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;nil AllocatingByteSliceSink *[]byte dst&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	*s.dst = cloneBytes(b) <span class="comment">// clone后赋值，如果b被更改，这里的dst不会变</span></span><br><span class="line">	s.v.b = b</span><br><span class="line">	s.v.s = <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过proto的Message类型和[]byte类型进行赋值，内部均调用了上面setBytesOwned方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *allocBytesSink)</span> <span class="title">SetProto</span><span class="params">(m proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	b, err := proto.Marshal(m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.setBytesOwned(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *allocBytesSink)</span> <span class="title">SetBytes</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.setBytesOwned(cloneBytes(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>string类型的赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *allocBytesSink)</span> <span class="title">SetString</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.dst == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;nil AllocatingByteSliceSink *[]byte dst&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	*s.dst = []<span class="keyword">byte</span>(v)</span><br><span class="line">	s.v.b = <span class="literal">nil</span></span><br><span class="line">	s.v.s = v</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>groupcache</category>
      </categories>
      <tags>
        <tag>groupcache</tag>
      </tags>
  </entry>
  <entry>
    <title>groupcache源码分析5:byteview.go</title>
    <url>/2020/03/15/groupcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905/</url>
    <content><![CDATA[<p>byteview.go文件提供了一个数据结构ByteView，它是对[]byte或string类型的一个封装，提供了一些方法。</p>
<a id="more"></a>

<ol>
<li><p>结构体定义，含有[]byte类型b和string类型s，优先使用b，b为nil再使用s。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteView <span class="keyword">struct</span> &#123;</span><br><span class="line">	b []<span class="keyword">byte</span></span><br><span class="line">	s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(v.b)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(v.s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于结构体内容，返回一个[]byte类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">ByteSlice</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> cloneBytes(v.b)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">byte</span>(v.s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于结构体内容，返回一个string类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">string</span>(v.b)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回数据中指定位置的原始字节。<strong>这里有一个小细节值得注意，那就是v.s[i]返回的是原始字节，而并不是如我们所想的返回字符串中某一个字符。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">At</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> v.b[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.s[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取数据，返回的仍然是一个ByteView。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">Slice</span><span class="params">(from, to <span class="keyword">int</span>)</span> <span class="title">ByteView</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;b: v.b[from:to]&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ByteView&#123;s: v.s[from:to]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取指定索引位置到结尾的数据，返回ByteView。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">SliceFrom</span><span class="params">(from <span class="keyword">int</span>)</span> <span class="title">ByteView</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;b: v.b[from:]&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ByteView&#123;s: v.s[from:]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝数据到一个[]byte变量中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">Copy</span><span class="params">(dest []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">copy</span>(dest, v.b)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">copy</span>(dest, v.s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个ByteView做比较。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">Equal</span><span class="params">(b2 ByteView)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b2.b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> v.EqualString(b2.s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.EqualBytes(b2.b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与字符串做比较，如果v的b为空，那么直接拿string类型s判断是否相等即可。否则，需要拿[]byte类型b和string比较，先判断长度是否相等，再逐个字节比对。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">EqualString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> v.s == s</span><br><span class="line">	&#125;</span><br><span class="line">	l := v.Len()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) != l &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, bi := <span class="keyword">range</span> v.b &#123;</span><br><span class="line">		<span class="keyword">if</span> bi != s[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与上一个方法类似，只不过是与[]byte的比较。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">EqualBytes</span><span class="params">(b2 []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bytes.Equal(v.b, b2)</span><br><span class="line">	&#125;</span><br><span class="line">	l := v.Len()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(b2) != l &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, bi := <span class="keyword">range</span> b2 &#123;</span><br><span class="line">		<span class="keyword">if</span> bi != v.s[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用NewReader方法返回io.ReadSeeker类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">Reader</span><span class="params">()</span> <span class="title">io</span>.<span class="title">ReadSeeker</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bytes.NewReader(v.b)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings.NewReader(v.s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从ByteView指定位置读取数据拷贝到[]byte中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">ReadAt</span><span class="params">(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> off &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;view: invalid offset&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> off &gt;= <span class="keyword">int64</span>(v.Len()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">	&#125;</span><br><span class="line">	n = v.SliceFrom(<span class="keyword">int</span>(off)).Copy(p)</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="built_in">len</span>(p) &#123;</span><br><span class="line">		err = io.EOF</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取数据写入到ByteView中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">if</span> v.b != <span class="literal">nil</span> &#123;</span><br><span class="line">		m, err = w.Write(v.b)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m, err = io.WriteString(w, v.s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; m &lt; v.Len() &#123;</span><br><span class="line">		err = io.ErrShortWrite</span><br><span class="line">	&#125;</span><br><span class="line">	n = <span class="keyword">int64</span>(m)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>groupcache</category>
      </categories>
      <tags>
        <tag>groupcache</tag>
      </tags>
  </entry>
  <entry>
    <title>groupcache源码分析7:peers.go</title>
    <url>/2020/03/22/groupcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%907/</url>
    <content><![CDATA[<p>peers.go文件的主要作用是用来定义如何查找和与其他peer沟通，peer的中文翻译为同伴，可以理解为其他机器。</p>
<a id="more"></a>

<ol>
<li><p>ProtoGetter必须被一个peer实现，他有一个Get方法用来获取返回值。PeerPicker接口是用来根据key寻找peer，如果返回nil,false，那么说明，该缓存的拥有者为自身。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ProtoGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get(ctx context.Context, in *pb.GetRequest, out *pb.GetResponse) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PeerPicker <span class="keyword">interface</span> &#123;</span><br><span class="line">	PickPeer(key <span class="keyword">string</span>) (peer ProtoGetter, ok <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NoPeers结构体，表示没有找到peer。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NoPeers <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(NoPeers)</span> <span class="title">PickPeer</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(peer ProtoGetter, ok <span class="keyword">bool</span>)</span></span> &#123; <span class="keyword">return</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量portPicker是一个func，返回值为PeerPicker，只能被定义一次。RegisterPeerPicker和RegisterPerGroupPeerPicker两者之一会被调用，调用时机为第一个group创建时，目的是为portPicker赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	portPicker <span class="function"><span class="keyword">func</span><span class="params">(groupName <span class="keyword">string</span>)</span> <span class="title">PeerPicker</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterPeerPicker</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="title">PeerPicker</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> portPicker != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;RegisterPeerPicker called more than once&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	portPicker = <span class="function"><span class="keyword">func</span><span class="params">(_ <span class="keyword">string</span>)</span> <span class="title">PeerPicker</span></span> &#123; <span class="keyword">return</span> fn() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterPerGroupPeerPicker</span><span class="params">(fn <span class="keyword">func</span>(groupName <span class="keyword">string</span>)</span> <span class="title">PeerPicker</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> portPicker != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;RegisterPeerPicker called more than once&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	portPicker = fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getPeers用来返回注册的PeerPicker方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPeers</span><span class="params">(groupName <span class="keyword">string</span>)</span> <span class="title">PeerPicker</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> portPicker == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> NoPeers&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pk := portPicker(groupName)</span><br><span class="line">	<span class="keyword">if</span> pk == <span class="literal">nil</span> &#123;</span><br><span class="line">		pk = NoPeers&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>groupcache</category>
      </categories>
      <tags>
        <tag>groupcache</tag>
      </tags>
  </entry>
  <entry>
    <title>groupcache源码分析8:http.go</title>
    <url>/2020/03/24/groupcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%908/</url>
    <content><![CDATA[<p>http.go定义了groupcache接收到http请求时怎么去执行操作，算是一个主要流程文件。</p>
<a id="more"></a>

<ol>
<li><p>定义两个常量，作为服务的默认值，defaultBasePath是请求路径，defaultReplicas是前面一致性哈希提到的单台机器虚拟结点数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultBasePath = <span class="string">&quot;/_groupcache/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultReplicas = <span class="number">50</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPPool为文件的核心，它是一个实现了PeerPicker接口的peer池。Context是上下文返回方法，如果没有设置使用默认的。Transport返回http.RoundTripper，没有同样使用默认的，它相当于http请求的中间件。self默认地址。opts为相关配置。改动peers和httpGetters时，通过mu来加锁。peers是之前一致性哈希章节中定义的结构体类型，用来存取peer。httpGetters存储地址与httpGetter对应关系。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HTTPPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context <span class="function"><span class="keyword">func</span><span class="params">(*http.Request)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"></span><br><span class="line">	Transport <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span> <span class="title">http</span>.<span class="title">RoundTripper</span></span></span><br><span class="line"></span><br><span class="line">	self <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	opts HTTPPoolOptions</span><br><span class="line"></span><br><span class="line">	mu          sync.Mutex </span><br><span class="line">	peers       *consistenthash.Map</span><br><span class="line">	httpGetters <span class="keyword">map</span>[<span class="keyword">string</span>]*httpGetter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPPool用到的配置项。HashFn是哈希计算方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HTTPPoolOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">	BasePath <span class="keyword">string</span></span><br><span class="line">	Replicas <span class="keyword">int</span></span><br><span class="line">	HashFn consistenthash.Hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建方法，NewHTTPPoolOpts返回一个*HTTPPool，因为它实现了ServeHTTP，被注册为http处理方法。httpPoolMade变量保证HTTPPool只会被初始化一次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPPool</span><span class="params">(self <span class="keyword">string</span>)</span> *<span class="title">HTTPPool</span></span> &#123;</span><br><span class="line">	p := NewHTTPPoolOpts(self, <span class="literal">nil</span>)</span><br><span class="line">	http.Handle(p.opts.BasePath, p)</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> httpPoolMade <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NewHTTPPoolOpts逻辑不复杂，主要是为结构体赋值，HTTPPool实现了PeerPicker接口，通过RegisterPeerPicker注册。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPPoolOpts</span><span class="params">(self <span class="keyword">string</span>, o *HTTPPoolOptions)</span> *<span class="title">HTTPPool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> httpPoolMade &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;groupcache: NewHTTPPool must be called only once&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	httpPoolMade = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	p := &amp;HTTPPool&#123;</span><br><span class="line">		self:        self,</span><br><span class="line">		httpGetters: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*httpGetter),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> o != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.opts = *o</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.opts.BasePath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		p.opts.BasePath = defaultBasePath</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.opts.Replicas == <span class="number">0</span> &#123;</span><br><span class="line">		p.opts.Replicas = defaultReplicas</span><br><span class="line">	&#125;</span><br><span class="line">	p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn)</span><br><span class="line"></span><br><span class="line">	RegisterPeerPicker(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">PeerPicker</span></span> &#123; <span class="keyword">return</span> p &#125;)</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set方法更新内容。先加锁，往peers写数据，然后再往httpGetters写数据。可以看到httpGetters的key是peer地址，val包含Transport和实际服务的url。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">Set</span><span class="params">(peers ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">	p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn) <span class="comment">//这里问什么又要new一次，没太看明白</span></span><br><span class="line">	p.peers.Add(peers...)</span><br><span class="line">	p.httpGetters = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*httpGetter, <span class="built_in">len</span>(peers))</span><br><span class="line">	<span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">		p.httpGetters[peer] = &amp;httpGetter&#123;transport: p.Transport, baseURL: peer + p.opts.BasePath&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PickPeer是根据请求的key来返回一个ProtoGetter，这里的数据结构都在peer.go中定义过。我们只要记住这个方法是通过key来得到对应的peer即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">PickPeer</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(ProtoGetter, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> p.peers.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> peer := p.peers.Get(key); peer != p.self &#123;</span><br><span class="line">		<span class="keyword">return</span> p.httpGetters[peer], <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个方法是我们接收到http请求实际去执行操作。先解析请求路径，获取group和key。通过名称获取Group对象，调用他的Get方法获取返回值（至于Group的具体内部定义我们下一篇会说）。封装数据，输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !strings.HasPrefix(r.URL.Path, p.opts.BasePath) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;HTTPPool serving unexpected path: &quot;</span> + r.URL.Path)</span><br><span class="line">	&#125;</span><br><span class="line">	parts := strings.SplitN(r.URL.Path[<span class="built_in">len</span>(p.opts.BasePath):], <span class="string">&quot;/&quot;</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">2</span> &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;bad request&quot;</span>, http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	groupName := parts[<span class="number">0</span>]</span><br><span class="line">	key := parts[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	group := GetGroup(groupName)</span><br><span class="line">	<span class="keyword">if</span> group == <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;no such group: &quot;</span>+groupName, http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> ctx context.Context</span><br><span class="line">	<span class="keyword">if</span> p.Context != <span class="literal">nil</span> &#123;</span><br><span class="line">		ctx = p.Context(r)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ctx = r.Context()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	group.Stats.ServerRequests.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">var</span> value []<span class="keyword">byte</span></span><br><span class="line">	err := group.Get(ctx, key, AllocatingByteSliceSink(&amp;value))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	body, err := proto.Marshal(&amp;pb.GetResponse&#123;Value: value&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-protobuf&quot;</span>)</span><br><span class="line">	w.Write(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>httpGetter结构体封装了两个属性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> httpGetter <span class="keyword">struct</span> &#123;</span><br><span class="line">	transport <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span> <span class="title">http</span>.<span class="title">RoundTripper</span></span></span><br><span class="line">	baseURL   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sync.Pool的概念可以参看这片文章<a href="https://www.jianshu.com/p/494cda4db297">https://www.jianshu.com/p/494cda4db297</a><br>。大概意思就是它提供了一个池子的功能，在里面会维护一定数目的对象，这样在高并发场景下，我们可以降低内存申请的开销。如果池子中没有可用对象，会调用New方法来初始化一个。使用完后通过Put方法将对象放回池中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bufferPool = sync.Pool&#123;</span><br><span class="line">	New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer) &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这是我们请求其他peer获取返回值的方法。先拼接请求路径，执行http请求。返回值的处理：从bufferPool中获取一个对象，Reset将其置空，copy得到返回值，然后解析成为对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpGetter)</span> <span class="title">Get</span><span class="params">(ctx context.Context, in *pb.GetRequest, out *pb.GetResponse)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	u := fmt.Sprintf(</span><br><span class="line">		<span class="string">&quot;%v%v/%v&quot;</span>,</span><br><span class="line">		h.baseURL,</span><br><span class="line">		url.QueryEscape(in.GetGroup()),</span><br><span class="line">		url.QueryEscape(in.GetKey()),</span><br><span class="line">	)</span><br><span class="line">	req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, u, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	req = req.WithContext(ctx)</span><br><span class="line">	tr := http.DefaultTransport</span><br><span class="line">	<span class="keyword">if</span> h.transport != <span class="literal">nil</span> &#123;</span><br><span class="line">		tr = h.transport(ctx)</span><br><span class="line">	&#125;</span><br><span class="line">	res, err := tr.RoundTrip(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;server returned: %v&quot;</span>, res.Status)</span><br><span class="line">	&#125;</span><br><span class="line">	b := bufferPool.Get().(*bytes.Buffer)</span><br><span class="line">	b.Reset()</span><br><span class="line">	<span class="keyword">defer</span> bufferPool.Put(b)</span><br><span class="line">	_, err = io.Copy(b, res.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;reading response body: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	err = proto.Unmarshal(b.Bytes(), out)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decoding response body: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>groupcache</category>
      </categories>
      <tags>
        <tag>groupcache</tag>
      </tags>
  </entry>
  <entry>
    <title>groupcache源码分析9:groupcache.go</title>
    <url>/2020/03/29/groupcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%909/</url>
    <content><![CDATA[<p>终于到了最后一个文件groupcache.go，跟项目同名，看着就知道它的重要性了。前面我们分析了那么多，这一篇就来看看如何利用那些零件，来具体去实现整个缓存逻辑。</p>
<a id="more"></a>

<ol>
<li><p>Getter接口，又一个Get方法，根据key查询到对应值，保存到dest中。GetterFunc是一个实现了Getter接口的func类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Getter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get(ctx context.Context, key <span class="keyword">string</span>, dest Sink) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetterFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f GetterFunc)</span> <span class="title">Get</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f(ctx, key, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一些使用到的变量。groups保存group与其对应结构体，initPeerServerOnce是一个sync.Once，它能保证Do方法只会被执行一次，实际上就是保证initPeerServer只会被执行一次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	mu     sync.RWMutex</span><br><span class="line">	groups = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Group)</span><br><span class="line"></span><br><span class="line">	initPeerServerOnce sync.Once</span><br><span class="line">	initPeerServer     <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>读锁并获取group名称对应的对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetGroup</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Group</span></span> &#123;</span><br><span class="line">	mu.RLock()</span><br><span class="line">	g := groups[name]</span><br><span class="line">	mu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Group，名称需保证唯一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroup</span><span class="params">(name <span class="keyword">string</span>, cacheBytes <span class="keyword">int64</span>, getter Getter)</span> *<span class="title">Group</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newGroup(name, cacheBytes, getter, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGroup</span><span class="params">(name <span class="keyword">string</span>, cacheBytes <span class="keyword">int64</span>, getter Getter, peers PeerPicker)</span> *<span class="title">Group</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> getter == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil Getter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	initPeerServerOnce.Do(callInitPeerServer) <span class="comment">//保证callInitPeerServer只会被调用一次</span></span><br><span class="line">	<span class="keyword">if</span> _, dup := groups[name]; dup &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;duplicate registration of group &quot;</span> + name)</span><br><span class="line">	&#125;</span><br><span class="line">	g := &amp;Group&#123;</span><br><span class="line">		name:       name,</span><br><span class="line">		getter:     getter,</span><br><span class="line">		peers:      peers,</span><br><span class="line">		cacheBytes: cacheBytes,</span><br><span class="line">		loadGroup:  &amp;singleflight.Group&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fn := newGroupHook; fn != <span class="literal">nil</span> &#123; <span class="comment">//钩子方法</span></span><br><span class="line">		fn(g)</span><br><span class="line">	&#125;</span><br><span class="line">	groups[name] = g</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Group时用到的几个关联项。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newGroupHook <span class="function"><span class="keyword">func</span><span class="params">(*Group)</span> //钩子，创建<span class="title">Group</span>时被调用。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterNewGroupHook</span><span class="params">(fn <span class="keyword">func</span>(*Group)</span>)</span> &#123; </span><br><span class="line">	<span class="keyword">if</span> newGroupHook != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;RegisterNewGroupHook called more than once&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newGroupHook = fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterServerStart</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> initPeerServer != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;RegisterServerStart called more than once&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	initPeerServer = fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callInitPeerServer</span><span class="params">()</span></span> &#123; <span class="comment">//钩子，当第一个Group被创建时调用。</span></span><br><span class="line">	<span class="keyword">if</span> initPeerServer != <span class="literal">nil</span> &#123;</span><br><span class="line">		initPeerServer()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Group结构体的定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	name       <span class="keyword">string</span> <span class="comment">//名称</span></span><br><span class="line">	getter     Getter <span class="comment">//获取缓存的方法</span></span><br><span class="line">	peersOnce  sync.Once</span><br><span class="line">	peers      PeerPicker</span><br><span class="line">	cacheBytes <span class="keyword">int64</span> <span class="comment">//缓存大小限制</span></span><br><span class="line"></span><br><span class="line">	mainCache cache <span class="comment">//属于当前peer的缓存</span></span><br><span class="line">	hotCache cache <span class="comment">//属于其他peer的缓存，但是被查询当前peer额外保存一份</span></span><br><span class="line"></span><br><span class="line">	loadGroup flightGroup <span class="comment">//竞争请求，前面的singleflight.go</span></span><br><span class="line"></span><br><span class="line">	_ <span class="keyword">int32</span> </span><br><span class="line">	Stats Stats <span class="comment">//统计值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> flightGroup <span class="keyword">interface</span> &#123;</span><br><span class="line">	Do(key <span class="keyword">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">	Gets           AtomicInt <span class="comment">//get请求总次数</span></span><br><span class="line">	CacheHits      AtomicInt <span class="comment">//从mainCache或hotCache命中的次数</span></span><br><span class="line">	PeerLoads      AtomicInt <span class="comment">//从其他peer获取数据的次数</span></span><br><span class="line">	PeerErrors     AtomicInt <span class="comment">//从其他peer获取数据错误的次数</span></span><br><span class="line">	Loads          AtomicInt <span class="comment">//非命中本peer的cache次数</span></span><br><span class="line">	LoadsDeduped   AtomicInt <span class="comment">//同一时间多请求只记一次</span></span><br><span class="line">	LocalLoads     AtomicInt <span class="comment">//从local获取数据总次数</span></span><br><span class="line">	LocalLoadErrs  AtomicInt <span class="comment">//从local获取数据错误次数</span></span><br><span class="line">	ServerRequests AtomicInt <span class="comment">//peer的所有http请求总次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Name方法返回名称。initPeers对peers属性赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> g.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">initPeers</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> g.peers == <span class="literal">nil</span> &#123;</span><br><span class="line">		g.peers = getPeers(g.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个方法是Group，根据参数key查询数据，然后将值放到dest里面。这里要注意下destPopulated的逻辑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Get</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	g.peersOnce.Do(g.initPeers) <span class="comment">//保证initPeers只被执行一次</span></span><br><span class="line">	g.Stats.Gets.Add(<span class="number">1</span>) <span class="comment">//统计http总数量</span></span><br><span class="line">	<span class="keyword">if</span> dest == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;groupcache: nil dest Sink&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	value, cacheHit := g.lookupCache(key) <span class="comment">//从mainCache和hotCache中查询</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cacheHit &#123; <span class="comment">//查询到统计+1并返回数据</span></span><br><span class="line">		g.Stats.CacheHits.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> setSinkView(dest, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	destPopulated := <span class="literal">false</span></span><br><span class="line">    <span class="comment">//同时多个请求，只有真正执行了的那个call，才会destPopulated返回true</span></span><br><span class="line">    <span class="comment">//为避免对dest中的值（实际时指针）重复赋值，只需要执行一次</span></span><br><span class="line">	value, destPopulated, err := g.load(ctx, key, dest) </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> destPopulated &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> setSinkView(dest, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>依次从mainCache和hotCache获取数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">lookupCache</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value ByteView, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> g.cacheBytes &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	value, ok = g.mainCache.get(key)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	value, ok = g.hotCache.get(key)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载数据。</p>
</li>
</ol>
<p>Do方法中又再次进行了lookupCache，注释里是这么说的，singleflight只能对同时重叠的调用进行处理，假设有两个请求同时错过了cache，会导致load被调用两次，不幸的情况会导致cache.nbytes做出错误的计算。</p>
<p>我们梳理一下上面这段话，按照singleflight的逻辑，如果两个请求同时进入了Do方法，因为lock的缘故，第一个获的锁的执行，第二个等待锁释放，然后拿到call的返回值，实际并未执行。一开始我没想通，这样冲突不是不存在吗，为啥还要lookupCache一次呢？事实上，可能存在这一种情况，两个请求过来都没查到缓存，然后同时进入load方法，假如现在第一个执行的比较快，在第二个还没有获取锁就执行完毕退出了，则请求二成功获取锁，执行操作并且增加cache.nbytes，那么就会计算不正确了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">load</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="params">(value ByteView, destPopulated <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	g.Stats.Loads.Add(<span class="number">1</span>)</span><br><span class="line">	viewi, err := g.loadGroup.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> value, cacheHit := g.lookupCache(key); cacheHit &#123;</span><br><span class="line">			g.Stats.CacheHits.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		g.Stats.LoadsDeduped.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">var</span> value ByteView</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		<span class="keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123; <span class="comment">//获取peer，如果peer是自身返回nil</span></span><br><span class="line">			value, err = g.getFromPeer(ctx, peer, key) <span class="comment">//从peer获取值</span></span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				g.Stats.PeerLoads.Add(<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			g.Stats.PeerErrors.Add(<span class="number">1</span>)			</span><br><span class="line">		&#125;</span><br><span class="line">		value, err = g.getLocally(ctx, key, dest) <span class="comment">//从本地获取数据</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			g.Stats.LocalLoadErrs.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		g.Stats.LocalLoads.Add(<span class="number">1</span>)</span><br><span class="line">		destPopulated = <span class="literal">true</span> <span class="comment">// dest已经被填充</span></span><br><span class="line">		g.populateCache(key, value, &amp;g.mainCache) <span class="comment">//数据加到mainCache中</span></span><br><span class="line">		<span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		value = viewi.(ByteView)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><p>从其他peer获取数据，peer.Get实际就是httpGetter的Get方法。这里使用了一个随机函数，一定概率会将其放入hotCache。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getFromPeer</span><span class="params">(ctx context.Context, peer ProtoGetter, key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	req := &amp;pb.GetRequest&#123;</span><br><span class="line">		Group: &amp;g.name,</span><br><span class="line">		Key:   &amp;key,</span><br><span class="line">	&#125;</span><br><span class="line">	res := &amp;pb.GetResponse&#123;&#125;</span><br><span class="line">	err := peer.Get(ctx, req, res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	value := ByteView&#123;b: res.Value&#125;</span><br><span class="line">	<span class="keyword">if</span> rand.Intn(<span class="number">10</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		g.populateCache(key, value, &amp;g.hotCache)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getLocally中实际调用的Get方法是我们在创建Group的时候去设定的，我们会在后面实际使用中介绍。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getLocally</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	err := g.getter.Get(ctx, key, dest)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dest.view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置缓存。假如当前缓存总大小超过了上线，那么使用lru来去除最老的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">populateCache</span><span class="params">(key <span class="keyword">string</span>, value ByteView, cache *cache)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> g.cacheBytes &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	cache.add(key, value)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		mainBytes := g.mainCache.bytes()</span><br><span class="line">		hotBytes := g.hotCache.bytes()</span><br><span class="line">		<span class="keyword">if</span> mainBytes+hotBytes &lt;= g.cacheBytes &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		victim := &amp;g.mainCache</span><br><span class="line">		<span class="keyword">if</span> hotBytes &gt; mainBytes/<span class="number">8</span> &#123;</span><br><span class="line">			victim = &amp;g.hotCache</span><br><span class="line">		&#125;</span><br><span class="line">		victim.removeOldest()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	MainCache CacheType = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">	HotCache</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回Group中的缓存统计信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">CacheStats</span><span class="params">(which CacheType)</span> <span class="title">CacheStats</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> which &#123;</span><br><span class="line">	<span class="keyword">case</span> MainCache:</span><br><span class="line">		<span class="keyword">return</span> g.mainCache.stats()</span><br><span class="line">	<span class="keyword">case</span> HotCache:</span><br><span class="line">		<span class="keyword">return</span> g.hotCache.stats()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> CacheStats&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cache结构体定义，与统计信息返回方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu         sync.RWMutex</span><br><span class="line">	nbytes     <span class="keyword">int64</span> <span class="comment">// 缓存大小</span></span><br><span class="line">	lru        *lru.Cache <span class="comment">//缓存主体，lru</span></span><br><span class="line">	nhit, nget <span class="keyword">int64</span> <span class="comment">//命中和请求数</span></span><br><span class="line">	nevict     <span class="keyword">int64</span> <span class="comment">// 驱逐数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">stats</span><span class="params">()</span> <span class="title">CacheStats</span></span> &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> CacheStats&#123;</span><br><span class="line">		Bytes:     c.nbytes,</span><br><span class="line">		Items:     c.itemsLocked(),</span><br><span class="line">		Gets:      c.nget,</span><br><span class="line">		Hits:      c.nhit,</span><br><span class="line">		Evictions: c.nevict,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CacheStats <span class="keyword">struct</span> &#123;</span><br><span class="line">	Bytes     <span class="keyword">int64</span></span><br><span class="line">	Items     <span class="keyword">int64</span></span><br><span class="line">	Gets      <span class="keyword">int64</span></span><br><span class="line">	Hits      <span class="keyword">int64</span></span><br><span class="line">	Evictions <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加缓存方法，基于lru的Add。注意这里的nbytes计算，包含key和val的总长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">add</span><span class="params">(key <span class="keyword">string</span>, value ByteView)</span></span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.lru == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.lru = &amp;lru.Cache&#123;</span><br><span class="line">			OnEvicted: <span class="function"><span class="keyword">func</span><span class="params">(key lru.Key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				val := value.(ByteView)</span><br><span class="line">				c.nbytes -= <span class="keyword">int64</span>(<span class="built_in">len</span>(key.(<span class="keyword">string</span>))) + <span class="keyword">int64</span>(val.Len())</span><br><span class="line">				c.nevict++</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.lru.Add(key, value)</span><br><span class="line">	c.nbytes += <span class="keyword">int64</span>(<span class="built_in">len</span>(key)) + <span class="keyword">int64</span>(value.Len())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取缓存。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value ByteView, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	c.nget++</span><br><span class="line">	<span class="keyword">if</span> c.lru == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	vi, ok := c.lru.Get(key)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.nhit++</span><br><span class="line">	<span class="keyword">return</span> vi.(ByteView), <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除老旧数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">removeOldest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.lru != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.lru.RemoveOldest()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取缓存总大小和总数量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">bytes</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> c.nbytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">items</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> c.itemsLocked()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">itemsLocked</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.lru == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int64</span>(c.lru.Len())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装方法，用来完成对int64的原子操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AtomicInt <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *AtomicInt)</span> <span class="title">Add</span><span class="params">(n <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	atomic.AddInt64((*<span class="keyword">int64</span>)(i), n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *AtomicInt)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.LoadInt64((*<span class="keyword">int64</span>)(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *AtomicInt)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.FormatInt(i.Get(), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>groupcache</category>
      </categories>
      <tags>
        <tag>groupcache</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2020/04/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找是在有序数组中进行查询的方法，思路虽简单，但是关于各种边界、+1、-1，总是会出现错误。这里以左闭右闭的形式，进行总结，做到简单易懂。</p>
<a id="more"></a>

<ol>
<li><p>普通二分查找<br>high选取的是len(nums)-1，如此形成的是左闭右闭区间，也有很多其他地方使用左闭右开，但我觉得不易于理解和记忆。<br>mid我们使用low + (high-low)/2来获取，是为了避免溢出，(high+low)/2分子可能会超出数据上限。<br>因为左闭右闭，所以mid位置的数据我们已经查询过，所以小于target，我们将low=mid+1。大于target，high=mid-1。等于直接返回。没有查找到返回-1。另外循环条件是&lt;=，也需要注意下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := low + (high-low)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左边界查找<br>主体上和普通二分查找差别不大，但要注意三个差异点。<br>一是相等时high = mid - 1，因为我们是查找左边界，当相等的时候，可能左侧还有符合的数字，此时需要收缩右边界。<br>二是返回值为low，我们记住查做边界，那么返回左侧。结合上一条思考下，为什么这样可以返回符合的值呢？当nums[mid]==target，收缩边界，假若此时mid正好是左边界位置，那么对[low,mid-1]继续查询，因为一直小于low不断+1，知道low&gt;mid-1，即mid。<br>三是特殊判断，因为low的取值是不停+1，最坏情况超出上界，需要做处理，另外当循环中断时，返回索引可能不符合条件，同样要判断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">left</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := low + (high-low)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">			high = mid - <span class="number">1</span> <span class="comment">//注意</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> low &gt;= <span class="built_in">len</span>(nums) || nums[low] != target &#123; <span class="comment">//注意</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low <span class="comment">//注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右边界查找<br>基本和查做边界差不多，差异在：<br>low=mid+1收缩左边界<br>high不停-1，做边界检查<br>查询的是右边界，返回值为high</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">right</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := low + (high-low)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">			low = mid + <span class="number">1</span> <span class="comment">//注意</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> high &lt; <span class="number">0</span> || nums[high] != target &#123; <span class="comment">//注意</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> high <span class="comment">//注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/09/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>以第一个数为基准数，先从右找到一个小于它的数位置i，再从左找到一个大于它的数位置j，交换两数字。循环执行，直到i==j此时中断循环，因为先从右寻找所以i可以保证为比base小的数字，最后将他俩交换，至此i左侧全为小于等于的数字，i右侧全为大于等于的数字，然后递归区间。</p>
<a id="more"></a>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	base := nums[left] <span class="comment">//基准数</span></span><br><span class="line">	i := left</span><br><span class="line">	j := right</span><br><span class="line">	<span class="keyword">for</span> i != j &#123;</span><br><span class="line">		<span class="keyword">for</span> nums[j] &gt;= base &amp;&amp; i &lt; j &#123;</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> nums[i] &lt;= base &amp;&amp; i &lt; j &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">	nums[left], nums[i] = nums[i], nums[left]</span><br><span class="line">	quickSort(nums, left, i <span class="number">-1</span>)</span><br><span class="line">	quickSort(nums,i+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
